# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/mprelude/all/mprelude.rbi
#
# mprelude-0.1.0

module MPrelude
end
module MPrelude::RequireBlock
  def require_block; end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
end
class MPrelude::Maybe
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Memoizable
end
class MPrelude::Maybe::Nothing < MPrelude::Maybe
  def bind(&block); end
  def fmap(&block); end
  def new; end
end
class MPrelude::Maybe::Just < MPrelude::Maybe
  def bind; end
  def fmap; end
  include Anonymous_Concord_2
  include Anonymous_Module_1
end
module Anonymous_Module_1
  def initialize(*args); end
  def value; end
  include Anonymous_Equalizer_3
  include Equalizer::Methods
end
module Anonymous_Equalizer_3
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_2
end
class MPrelude::Either
  def left?; end
  def right?; end
  def self.new(*args, &block); end
  def self.wrap_error(*exceptions); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Anonymous_Module_4
  include Memoizable
end
module Anonymous_Module_4
  def initialize(*args); end
  def value; end
  include Anonymous_Equalizer_5
  include Equalizer::Methods
end
module Anonymous_Equalizer_5
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class MPrelude::Either::Left < MPrelude::Either
  def bind(&block); end
  def either(left, _right); end
  def fmap(&block); end
  def from_left; end
  def from_right; end
  def lmap; end
end
class MPrelude::Either::Right < MPrelude::Either
  def bind; end
  def either(_left, right); end
  def fmap; end
  def from_left; end
  def from_right; end
  def lmap(&block); end
end
