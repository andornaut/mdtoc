# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/unparser/all/unparser.rbi
#
# unparser-0.4.9

module Unparser
  def self.buffer(source); end
  def self.consume_diagnostic(diagnostic); end
  def self.parse(source); end
  def self.parse_either(source); end
  def self.parse_with_comments(source); end
  def self.parser; end
  def self.unparse(node, comment_array = nil); end
end
class Unparser::Buffer
  def append(string); end
  def append_without_prefix(string); end
  def capture_content; end
  def content; end
  def fresh_line?; end
  def indent; end
  def initialize; end
  def nl; end
  def prefix; end
  def unindent; end
  def write(fragment); end
end
module Unparser::NodeHelpers
  def n(type, children = nil); end
  def s(type, *children); end
end
class Unparser::Preprocessor
  def children; end
  def result(*arg0); end
  def self.call(*args); end
  def self.new(*args, &block); end
  def self.register(type); end
  def self.run(node, parent_type = nil); end
  def visit(child); end
  def visited_children; end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Procto::ClassMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_6
  include Memoizable
end
module Anonymous_Module_6
  def initialize(*args); end
  def node; end
  def parent_type; end
  include Anonymous_Equalizer_7
  include Equalizer::Methods
end
module Anonymous_Equalizer_7
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Preprocessor::Noop < Unparser::Preprocessor
  def result; end
end
class Unparser::Preprocessor::Infinity < Unparser::Preprocessor
  def result; end
end
class Unparser::Preprocessor::Begin < Unparser::Preprocessor
  def result; end
end
class Unparser::Comments
  def consume(node, source_part = nil); end
  def initialize(comments); end
  def self.source_range(node, part); end
  def source_range(*arguments); end
  def take_all; end
  def take_before(node, source_part); end
  def take_eol_comments; end
  def take_up_to_line(line); end
  def take_while; end
  def unshift_documents(comments); end
end
module Unparser::Constants
  def self.symbol_set(enumerable); end
end
module Unparser::DSL
  def children(*names); end
  def define_child(name, index); end
  def define_group(name, range); end
  def define_remaining_children(names); end
end
module Unparser::AST
  def self.local_variable_assignments(node); end
  def self.local_variable_reads(node); end
  def self.not_close_scope?(node); end
  def self.not_reset_scope?(node); end
end
class Unparser::AST::Enumerator
  def each(&block); end
  def self.new(node, controller = nil); end
  def self.set(enumerable); end
  def self.type(node, type); end
  def type(type); end
  def types(types); end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_8
  include Memoizable
end
module Anonymous_Module_8
  def controller; end
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_9
  include Equalizer::Methods
end
module Anonymous_Equalizer_9
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::AST::Walker
  def call(node); end
  def self.call(node, controller = nil, &block); end
  include Anonymous_Concord_11
  include Anonymous_Module_10
end
module Anonymous_Module_10
  def block; end
  def controller; end
  def initialize(*args); end
  include Anonymous_Equalizer_12
  include Equalizer::Methods
end
module Anonymous_Equalizer_12
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_11
end
class Unparser::AST::LocalVariableScope
  def first_assignment?(node); end
  def first_assignment_in_body_and_used_in_condition?(body, condition); end
  def initialize(node); end
  def local_variable_defined_for_node?(node, name); end
  def match(needle); end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Anonymous_Module_13
  include Enumerable
  include Memoizable
end
module Anonymous_Module_13
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_14
  include Equalizer::Methods
end
module Anonymous_Equalizer_14
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::AST::LocalVariableScopeEnumerator
  def current; end
  def define(name); end
  def each(node, &block); end
  def enter(node); end
  def initialize; end
  def leave(node); end
  def pop; end
  def push_inherit; end
  def push_reset; end
  def self.each(node, &block); end
  def visit(node, &block); end
  include Enumerable
end
class Unparser::Diff
  def colorized_diff(&block); end
  def diff(&block); end
  def diffs; end
  def hunks; end
  def max_length; end
  def minimized_hunk; end
  def self.build(old, new); end
  def self.colorize_line(line); end
  def self.lines(source); end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_15
  include Memoizable
end
module Anonymous_Module_15
  def initialize(*args); end
  def new; end
  def old; end
  include Anonymous_Equalizer_16
  include Equalizer::Methods
end
module Anonymous_Equalizer_16
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Color
  def format(text); end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_17
  include Memoizable
end
module Anonymous_Module_17
  def code; end
  def initialize(*args); end
  include Anonymous_Equalizer_18
  include Equalizer::Methods
end
module Anonymous_Equalizer_18
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::UnknownNodeError < ArgumentError
end
class Unparser::Emitter
  def buffer(&block); end
  def children; end
  def comments(&block); end
  def conditional_parentheses(flag); end
  def delimited(nodes, &block); end
  def delimited_plain(nodes); end
  def dispatch(*arg0); end
  def emit_body(body = nil); end
  def emit_comments(comments); end
  def emit_comments_before(source_part = nil); end
  def emit_eof_comments; end
  def emit_eol_comments; end
  def emitter(node); end
  def first_child; end
  def indented; end
  def k_end; end
  def local_variable_scope; end
  def local_variables(*arg0); end
  def nl; end
  def node_type; end
  def parent_type; end
  def parentheses(open = nil, close = nil); end
  def run(emitter, node = nil); end
  def self.emitter(node, parent); end
  def self.handle(*types); end
  def self.new(*args, &block); end
  def terminated?(*arg0); end
  def visit(node); end
  def visit_indented(node); end
  def visit_parentheses(node, *arguments); end
  def visit_plain(node); end
  def write(*strings); end
  def write_to_buffer(&block); end
  def ws; end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Unparser::DSL
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Concord_20
  include Anonymous_Module_19
  include Memoizable
end
module Anonymous_Module_19
  def initialize(*args); end
  def node; end
  def parent; end
  include Anonymous_Equalizer_21
  include Equalizer::Methods
end
module Anonymous_Equalizer_21
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_20
end
module Unparser::Emitter::Unterminated
  def terminated?; end
end
module Unparser::Emitter::Terminated
  def terminated?; end
end
module Unparser::Emitter::LocalVariableRoot
  def local_variable_scope; end
  def self.included(descendant); end
end
class Unparser::Emitter::Literal < Unparser::Emitter
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Literal::Primitive < Unparser::Emitter::Literal
  def remaining_children; end
  def value; end
end
class Unparser::Emitter::Literal::Primitive::Inspect < Unparser::Emitter::Literal::Primitive
  def dispatch; end
end
class Unparser::Emitter::Literal::Primitive::Complex < Unparser::Emitter::Literal::Primitive
  def dispatch; end
  def emit_imaginary; end
  def imaginary_node; end
end
class Unparser::Emitter::Literal::Primitive::Rational < Unparser::Emitter::Literal::Primitive
  def dispatch; end
  def write_rational(value); end
end
class Unparser::Emitter::Literal::Primitive::Numeric < Unparser::Emitter::Literal::Primitive
  def dispatch; end
end
class Unparser::Emitter::Literal::Singleton < Unparser::Emitter::Literal
  def dispatch; end
end
class Unparser::Emitter::Literal::Dynamic < Unparser::Emitter::Literal
  def dispatch; end
  def dynamic_body; end
end
class Unparser::Emitter::Literal::Dynamic::String < Unparser::Emitter::Literal::Dynamic
end
class Unparser::Emitter::Literal::Dynamic::Symbol < Unparser::Emitter::Literal::Dynamic
end
class Unparser::Emitter::Literal::Regexp < Unparser::Emitter::Literal
  def body; end
  def dispatch; end
  def dynamic_body; end
  def dynamic_body_children; end
  def escape(child); end
  def write_body(node); end
end
class Unparser::Emitter::Literal::Regopt < Unparser::Emitter::Literal
  def dispatch; end
end
class Unparser::Emitter::Literal::Array < Unparser::Emitter::Literal
  def dispatch; end
end
class Unparser::Emitter::Literal::HashPair < Unparser::Emitter::Literal
  def emit_value; end
  def key; end
  def remaining_children; end
  def value; end
end
class Unparser::Emitter::Literal::HashPair::Rocket < Unparser::Emitter::Literal::HashPair
  def dispatch; end
end
class Unparser::Emitter::Literal::HashPair::Colon < Unparser::Emitter::Literal::HashPair
  def dispatch; end
end
class Unparser::Emitter::Literal::HashBody < Unparser::Emitter::Literal
  def dispatch; end
  def effective_body; end
end
class Unparser::Emitter::Literal::Hash < Unparser::Emitter::Literal
  def dispatch; end
  def emit_hash_body; end
end
class Unparser::Emitter::Literal::Range < Unparser::Emitter::Literal
  def begin_node; end
  def dispatch; end
  def end_node; end
  def remaining_children; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Literal::DynamicBody < Unparser::Emitter::Literal
  def dispatch; end
  def emit_interpolated_segment(node); end
  def emit_segment(node); end
  def emit_str_segment(node); end
end
class Unparser::Emitter::Literal::DynamicBody::Interpolation < Unparser::Emitter::Literal::DynamicBody
  def dispatch; end
  def remaining_children; end
  def subject; end
end
class Unparser::Emitter::Literal::DynamicBody::String < Unparser::Emitter::Literal::DynamicBody
end
class Unparser::Emitter::Literal::DynamicBody::Regexp < Unparser::Emitter::Literal::DynamicBody
end
class Unparser::Emitter::Literal::DynamicBody::ExecuteString < Unparser::Emitter::Literal::DynamicBody
end
class Unparser::Emitter::Literal::ExecuteString < Unparser::Emitter::Literal
  def dispatch; end
  def dynamic_body; end
end
class Unparser::Emitter::Meta < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Send < Unparser::Emitter
  def arguments(&block); end
  def arguments?; end
  def assignment?; end
  def attribute_assignment?; end
  def avoid_clash?; end
  def binary_operator?; end
  def dispatch; end
  def effective_arguments; end
  def effective_emitter; end
  def effective_emitter_class; end
  def emit_arguments; end
  def emit_selector; end
  def local_variable_clash?; end
  def mlhs?; end
  def non_assignment_selector; end
  def normal_arguments; end
  def parses_as_constant?; end
  def receiver; end
  def remaining_children; end
  def selector; end
  def string_selector; end
  def terminated?; end
  def unary_operator?; end
end
class Unparser::Emitter::Send::Unary < Unparser::Emitter::Send
  def dispatch; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Send::Binary < Unparser::Emitter::Send
  def dispatch; end
  def emit_operator; end
  def emit_right; end
  def right_node; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Send::Regular < Unparser::Emitter::Send
  def dispatch; end
  def emit_receiver; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Send::Conditional < Unparser::Emitter::Send
  def dispatch; end
  def emit_receiver; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Send::AttributeAssignment < Unparser::Emitter::Send
  def dispatch; end
  def emit_attribute; end
  def emit_receiver; end
  def first_argument; end
  def receiver; end
  def remaining_children; end
  def selector; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Block < Unparser::Emitter
  def arguments; end
  def body; end
  def dispatch; end
  def emit_block_arguments; end
  def emit_target; end
  def remaining_children; end
  def stabby_lambda?; end
  def target; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Assignment < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::Assignment::Single < Unparser::Emitter::Assignment
  def emit_left(*arg0); end
  def emit_right; end
  def terminated?; end
end
class Unparser::Emitter::Assignment::Single::Variable < Unparser::Emitter::Assignment::Single
  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end
class Unparser::Emitter::Assignment::Single::Constant < Unparser::Emitter::Assignment::Single
  def base; end
  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end
class Unparser::Emitter::Assignment::Multiple < Unparser::Emitter::Assignment
  def emit_left; end
  def emit_right; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Assignment::MLHS < Unparser::Emitter
  def dispatch; end
  def mlhs?; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Variable < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Const < Unparser::Emitter
  def dispatch; end
  def emit_scope; end
  def name; end
  def remaining_children; end
  def scope; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::NthRef < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::KwSplat < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def subject; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Splat < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def subject; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::CBase < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::ArgExpr < Unparser::Emitter
  def body; end
  def dispatch; end
  def remaining_children; end
end
class Unparser::Emitter::Arguments < Unparser::Emitter
  def dispatch; end
  def normal_arguments(&block); end
  def procarg_disambiguator?; end
  def regular_block?; end
  def shadowargs(&block); end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Morearg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Optarg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::KeywordOptional < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Kwarg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Restarg < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Argument < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Procarg < Unparser::Emitter
  def dispatch; end
  def needs_parens?; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::BlockPass < Unparser::Emitter
  def dispatch; end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Begin < Unparser::Emitter
  def body; end
  def emit_inner; end
  def remaining_children; end
end
class Unparser::Emitter::Begin::Implicit < Unparser::Emitter::Begin
  def dispatch; end
  def terminated?; end
end
class Unparser::Emitter::Begin::Explicit < Unparser::Emitter::Begin
  def dispatch; end
  def emit_body; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::FlowModifier < Unparser::Emitter
  def dispatch; end
  def emit_argument(node); end
  def emit_arguments; end
  def emit_single_argument; end
  def terminated?; end
end
class Unparser::Emitter::Undef < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Def < Unparser::Emitter
  def body(*arg0); end
  def dispatch; end
  def emit_arguments; end
  def emit_name(*arg0); end
  def local_variable_scope(&block); end
  include Unparser::Emitter::LocalVariableRoot
end
class Unparser::Emitter::Def::Instance < Unparser::Emitter::Def
  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
end
class Unparser::Emitter::Def::Singleton < Unparser::Emitter::Def
  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
  def subject; end
  def subject_without_parens?; end
end
class Unparser::Emitter::Class < Unparser::Emitter
  def body; end
  def dispatch; end
  def emit_superclass; end
  def local_variable_scope(&block); end
  def name; end
  def remaining_children; end
  def superclass; end
  include Unparser::Emitter::LocalVariableRoot
end
class Unparser::Emitter::SClass < Unparser::Emitter
  def body; end
  def dispatch; end
  def object; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Module < Unparser::Emitter
  def body; end
  def dispatch; end
  def local_variable_scope(&block); end
  def name; end
  def remaining_children; end
  include Unparser::Emitter::LocalVariableRoot
end
class Unparser::Emitter::BinaryAssign < Unparser::Emitter
  def dispatch; end
  def expression; end
  def remaining_children; end
  def target; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::OpAssign < Unparser::Emitter
  def dispatch; end
  def emit_operator; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Defined < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def subject; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Hookexe < Unparser::Emitter
  def body; end
  def dispatch; end
  def remaining_children; end
end
class Unparser::Emitter::ZSuper < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Super < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Retry < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Redo < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::If < Unparser::Emitter
  def condition; end
  def dispatch; end
  def else_branch; end
  def emit_condition; end
  def emit_else_branch; end
  def emit_if_branch; end
  def emit_normal; end
  def emit_postcondition; end
  def if_branch; end
  def keyword; end
  def postcondition?; end
  def remaining_children; end
  def terminated?; end
  def unless?; end
end
class Unparser::Emitter::Alias < Unparser::Emitter
  def dispatch; end
  def remaining_children; end
  def source; end
  def target; end
end
class Unparser::Emitter::Yield < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Binary < Unparser::Emitter
  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Case < Unparser::Emitter
  def condition; end
  def dispatch; end
  def emit_condition; end
  def emit_else; end
  def emit_whens; end
  def remaining_children; end
  def whens(&block); end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::When < Unparser::Emitter
  def captures(&block); end
  def dispatch; end
  def emit_captures; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::For < Unparser::Emitter
  def assignment; end
  def body; end
  def condition; end
  def dispatch; end
  def emit_condition; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Post < Unparser::Emitter
  def body; end
  def condition; end
  def dispatch; end
  def remaining_children; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Repetition < Unparser::Emitter
  def body; end
  def condition; end
  def dispatch; end
  def emit_keyword; end
  def emit_normal; end
  def emit_postcontrol; end
  def postcontrol?; end
  def remaining_children; end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Root < Unparser::Emitter
  def buffer; end
  def comments; end
  def local_variable_scope(&block); end
  def node; end
  include Anonymous_Concord_Public_23
  include Anonymous_Module_22
  include Unparser::Emitter::LocalVariableRoot
end
module Anonymous_Module_22
  def buffer; end
  def comments; end
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_24
  include Equalizer::Methods
end
module Anonymous_Equalizer_24
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_23
end
class Unparser::Emitter::Match < Unparser::Emitter
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Match::Lvasgn < Unparser::Emitter::Match
  def dispatch; end
  def lvasgn; end
  def regexp; end
  def remaining_children; end
end
class Unparser::Emitter::Match::CurrentLine < Unparser::Emitter::Match
  def dispatch; end
  def regexp; end
  def remaining_children; end
end
class Unparser::Emitter::Empty < Unparser::Emitter
  def dispatch; end
end
class Unparser::Emitter::FlipFlop < Unparser::Emitter
  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Rescue < Unparser::Emitter
  def body; end
  def dispatch; end
  def else_branch; end
  def emit_else; end
  def emit_embedded; end
  def emit_standalone; end
  def remaining_children; end
  def rescue_bodies(&block); end
  def rescue_body; end
  def standalone?; end
  include Unparser::Emitter::Unterminated
end
class Unparser::Emitter::Resbody < Unparser::Emitter
  def assignment; end
  def body; end
  def exception; end
  def remaining_children; end
end
class Unparser::Emitter::Resbody::Standalone < Unparser::Emitter::Resbody
  def dispatch; end
end
class Unparser::Emitter::Resbody::Embedded < Unparser::Emitter::Resbody
  def dispatch; end
  def emit_assignment; end
  def emit_exception; end
end
class Unparser::Emitter::Ensure < Unparser::Emitter
  def body; end
  def dispatch; end
  def ensure_body; end
  def remaining_children; end
end
class Unparser::Emitter::Index < Unparser::Emitter
  def dispatch; end
  def emit_receiver; end
  def mlhs?; end
end
class Unparser::Emitter::Index::Reference < Unparser::Emitter::Index
  def emit_operation; end
  def indices(&block); end
  include Unparser::Emitter::Terminated
end
class Unparser::Emitter::Index::Assign < Unparser::Emitter::Index
  def emit_operation; end
  def emit_value?; end
  def indices; end
  def no_value_parent?; end
  def terminated?; end
end
class Unparser::Emitter::Lambda < Unparser::Emitter
  def dispatch; end
  include Unparser::Emitter::Terminated
end
class Unparser::Validation
  def generated_node; end
  def generated_source; end
  def identification; end
  def make_report(label, attribute_name); end
  def node_diff_report; end
  def original_node; end
  def original_source; end
  def report(&block); end
  def report_exception(exception); end
  def self.anima; end
  def self.const_unit(_value); end
  def self.from_path(path); end
  def self.from_string(original_source); end
  def self.unparse_either(node); end
  def success?; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_25
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_25
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Unparser::Builder < Parser::Builders::Default
end
